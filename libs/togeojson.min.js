/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@mapbox/togeojson@0.16.0/togeojson.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var toGeoJSON = function () { "use strict"; var e, t = /\s*/g, r = /^\s*|\s*$/g, n = /\s+/; function i(e) { if (!e || !e.length) return 0; for (var t = 0, r = 0; t < e.length; t++)r = (r << 5) - r + e.charCodeAt(t) | 0; return r } function o(e, t) { return e.getElementsByTagName(t) } function a(e, t) { return e.getAttribute(t) } function s(e, t) { return parseFloat(a(e, t)) } function l(e, t) { var r = o(e, t); return r.length ? r[0] : null } function u(e) { for (var t = 0, r = []; t < e.length; t++)r[t] = parseFloat(e[t]); return r } function f(e) { var t; return e && (t = e).normalize && t.normalize(), e && e.textContent || "" } function p(e, t) { var r, n, i = {}; for (n = 0; n < t.length; n++)(r = l(e, t[n])) && (i[t[n]] = f(r)); return i } function c(e, t) { for (var r in t) e[r] = t[r] } function h(e) { return u(e.replace(t, "").split(",")) } function g(e) { for (var t = e.replace(r, "").split(n), i = [], o = 0; o < t.length; o++)i.push(h(t[o])); return i } function m(e) { var t, r = [s(e, "lon"), s(e, "lat")], n = l(e, "ele"), i = l(e, "gpxtpx:hr") || l(e, "hr"), o = l(e, "time"); return n && (t = parseFloat(f(n)), isNaN(t) || r.push(t)), { coordinates: r, time: o ? f(o) : null, heartRate: i ? parseFloat(f(i)) : null } } function y(t) { return void 0 !== t.xml ? t.xml : e.serializeToString(t) } return "undefined" != typeof XMLSerializer ? e = new XMLSerializer : "object" != typeof exports || "object" != typeof process || process.browser || (e = new (require("xmldom").XMLSerializer)), { kml: function (e) { for (var t = { type: "FeatureCollection", features: [] }, r = {}, n = {}, s = {}, p = ["Polygon", "LineString", "Point", "Track", "gx:Track"], c = o(e, "Placemark"), m = o(e, "Style"), d = o(e, "StyleMap"), v = 0; v < m.length; v++) { var k = i(y(m[v])).toString(16); r["#" + a(m[v], "id")] = k, n[k] = m[v] } for (var S = 0; S < d.length; S++) { r["#" + a(d[S], "id")] = i(y(d[S])).toString(16); for (var T = o(d[S], "Pair"), x = {}, N = 0; N < T.length; N++)x[f(l(T[N], "key"))] = f(l(T[N], "styleUrl")); s["#" + a(d[S], "id")] = x } for (var b = 0; b < c.length; b++)t.features = t.features.concat(w(c[b])); function F(e) { var t, r; return "#" === (e = e || "").substr(0, 1) && (e = e.substr(1)), 6 !== e.length && 3 !== e.length || (t = e), 8 === e.length && (r = parseInt(e.substr(0, 2), 16) / 255, t = "#" + e.substr(6, 2) + e.substr(4, 2) + e.substr(2, 2)), [t, isNaN(r) ? void 0 : r] } function L(e) { var t = o(e, "coord"), r = [], n = []; 0 === t.length && (t = o(e, "gx:coord")); for (var i = 0; i < t.length; i++)r.push(u(f(t[i]).split(" "))); for (var a = o(e, "when"), s = 0; s < a.length; s++)n.push(f(a[s])); return { coords: r, times: n } } function M(e) { var t, r, n, i, a, s = [], u = []; if (l(e, "MultiGeometry")) return M(l(e, "MultiGeometry")); if (l(e, "MultiTrack")) return M(l(e, "MultiTrack")); if (l(e, "gx:MultiTrack")) return M(l(e, "gx:MultiTrack")); for (n = 0; n < p.length; n++)if (r = o(e, p[n])) for (i = 0; i < r.length; i++)if (t = r[i], "Point" === p[n]) s.push({ type: "Point", coordinates: h(f(l(t, "coordinates"))) }); else if ("LineString" === p[n]) s.push({ type: "LineString", coordinates: g(f(l(t, "coordinates"))) }); else if ("Polygon" === p[n]) { var c = o(t, "LinearRing"), m = []; for (a = 0; a < c.length; a++)m.push(g(f(l(c[a], "coordinates")))); s.push({ type: "Polygon", coordinates: m }) } else if ("Track" === p[n] || "gx:Track" === p[n]) { var y = L(t); s.push({ type: "LineString", coordinates: y.coords }), y.times.length && u.push(y.times) } return { geoms: s, coordTimes: u } } function w(e) { var t, i = M(e), u = {}, p = f(l(e, "name")), c = f(l(e, "address")), h = f(l(e, "styleUrl")), g = f(l(e, "description")), m = l(e, "TimeSpan"), y = l(e, "TimeStamp"), d = l(e, "ExtendedData"), v = l(e, "LineStyle"), k = l(e, "PolyStyle"), S = l(e, "visibility"); if (!i.geoms.length) return []; if (p && (u.name = p), c && (u.address = c), h) { "#" !== h[0] && (h = "#" + h), u.styleUrl = h, r[h] && (u.styleHash = r[h]), s[h] && (u.styleMapHash = s[h], u.styleHash = r[s[h].normal]); var T = n[u.styleHash]; T && (v || (v = l(T, "LineStyle")), k || (k = l(T, "PolyStyle"))) } if (g && (u.description = g), m) { var x = f(l(m, "begin")), N = f(l(m, "end")); u.timespan = { begin: x, end: N } } if (y && (u.timestamp = f(l(y, "when"))), v) { var b = F(f(l(v, "color"))), L = b[0], w = b[1], P = parseFloat(f(l(v, "width"))); L && (u.stroke = L), isNaN(w) || (u["stroke-opacity"] = w), isNaN(P) || (u["stroke-width"] = P) } if (k) { var R = F(f(l(k, "color"))), z = R[0], C = R[1], G = f(l(k, "fill")), A = f(l(k, "outline")); z && (u.fill = z), isNaN(C) || (u["fill-opacity"] = C), G && (u["fill-opacity"] = "1" === G ? u["fill-opacity"] || 1 : 0), A && (u["stroke-opacity"] = "1" === A ? u["stroke-opacity"] || 1 : 0) } if (d) { var H = o(d, "Data"), D = o(d, "SimpleData"); for (t = 0; t < H.length; t++)u[H[t].getAttribute("name")] = f(l(H[t], "value")); for (t = 0; t < D.length; t++)u[D[t].getAttribute("name")] = f(D[t]) } S && (u.visibility = f(S)), i.coordTimes.length && (u.coordTimes = 1 === i.coordTimes.length ? i.coordTimes[0] : i.coordTimes); var U = { type: "Feature", geometry: 1 === i.geoms.length ? i.geoms[0] : { type: "GeometryCollection", geometries: i.geoms }, properties: u }; return a(e, "id") && (U.id = a(e, "id")), [U] } return t }, gpx: function (e) { var t, r, n = o(e, "trk"), i = o(e, "rte"), s = o(e, "wpt"), u = { type: "FeatureCollection", features: [] }; for (t = 0; t < n.length; t++)(r = g(n[t])) && u.features.push(r); for (t = 0; t < i.length; t++)(r = y(i[t])) && u.features.push(r); for (t = 0; t < s.length; t++)u.features.push(d(s[t])); function h(e, t) { var r = o(e, t), n = [], i = [], a = [], s = r.length; if (s < 2) return {}; for (var l = 0; l < s; l++) { var u = m(r[l]); n.push(u.coordinates), u.time && i.push(u.time), u.heartRate && a.push(u.heartRate) } return { line: n, times: i, heartRates: a } } function g(e) { for (var t, r = o(e, "trkseg"), n = [], i = [], a = [], s = 0; s < r.length; s++)(t = h(r[s], "trkpt")) && (t.line && n.push(t.line), t.times && t.times.length && i.push(t.times), t.heartRates && t.heartRates.length && a.push(t.heartRates)); if (0 !== n.length) { var u = k(e); return c(u, v(l(e, "extensions"))), i.length && (u.coordTimes = 1 === n.length ? i[0] : i), a.length && (u.heartRates = 1 === n.length ? a[0] : a), { type: "Feature", properties: u, geometry: { type: 1 === n.length ? "LineString" : "MultiLineString", coordinates: 1 === n.length ? n[0] : n } } } } function y(e) { var t = h(e, "rtept"); if (t.line) { var r = k(e); return c(r, v(l(e, "extensions"))), { type: "Feature", properties: r, geometry: { type: "LineString", coordinates: t.line } } } } function d(e) { var t = k(e); return c(t, p(e, ["sym"])), { type: "Feature", properties: t, geometry: { type: "Point", coordinates: m(e).coordinates } } } function v(e) { var t = {}; if (e) { var r = l(e, "line"); if (r) { var n = f(l(r, "color")), i = parseFloat(f(l(r, "opacity"))), o = parseFloat(f(l(r, "width"))); n && (t.stroke = n), isNaN(i) || (t["stroke-opacity"] = i), isNaN(o) || (t["stroke-width"] = 96 * o / 25.4) } } return t } function k(e) { var t = p(e, ["name", "cmt", "desc", "type", "time", "keywords"]), r = o(e, "link"); r.length && (t.links = []); for (var n, i = 0; i < r.length; i++)c(n = { href: a(r[i], "href") }, p(r[i], ["text", "type"])), t.links.push(n); return t } return u } } }(); "undefined" != typeof module && (module.exports = toGeoJSON);
